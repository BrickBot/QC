// 0xXY
//      X = 0xef4X address
//      Y = bit number

#include "qc.h"

const char segcode[6][8] = {
  {0xa6, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82},	/* left */
  {0x65, 0xa1, 0x64, 0xa5, 0xa7, 0x67, 0xa3, 0xb6},
  {0x61, 0xb1, 0x60, 0xb5, 0xb7, 0x63, 0xb3, 0x96},
  {0x41, 0x81, 0x40, 0x95, 0x97, 0x43, 0x83, 0x86},
  {0x35, 0x71, 0x34, 0x85, 0x87, 0x37, 0x73, 0x82},
  {0x45, 0x55, 0x44, 0x75, 0x77, 0x47, 0x57, 0x82}	/* right */
};

const char ascii_display_codes[] =
{
  0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	// non-printables
   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	// -> underscore
   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	// except 0x00.
   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,

  0x00,				// 32 ' '
   0x42,			// 33 ! 1
   0x0a,			// 34 "
   0x7b,			// 35 #
   0x6d,			// 36 $ 5 S Z
   0x13,			// 37 % /
   0x7d,			// 38 & 6
   0x08,			// 39 '  alt: ` 
   0x3c,			// 40 ( C [ {
   0x66,			// 41 ) ] }
   0x5b,			// 42 * H K X
   0x43,			// 43 +  alt: 0x19 (worse)
   0x10,			// 44 , .  alt: 0x40
   0x01,			// 45 -
   0x10,			// 46 . alt: 0x40
   0x13,			// 47 /

  0x7e,				// 48 0 0
   0x42,			// 49 1
   0x37,			// 50 2
   0x67,			// 51 3
   0x4b,			// 52 4
   0x6d,			// 53 5
   0x7d,			// 54 6
   0x46,			// 55 7
   0x7f,			// 56 8
   0x4f,			// 57 9 Q q

  0x21,				// 58 : ; = alt:0x5 (worse)
   0x21,			// 59 ;
   0x31,			// 60 < c alt:0xd (worse)       
   0x21,			// 61 =
   0x61,			// 62 >   alt: 0x7 (worse)
   0x17,			// 63 ?
   0x3f,			// 64 @ alt: e

  0x5f,				// 65 A
   0x79,			// 66 b 
   0x3c,			// 67 C
   0x73,			// 68 d
   0x3d,			// 69 E
   0x1d,			// 70 F
   0x7c,			// 71 G
   0x5b,			// 72 H
   0x42,			// 73 I 1
   0x62,			// 74 J
   0x5b,			// 75 K
   0x38,			// 76 L
   0x5e,			// 77 M N
   0x5e,			// 78 N
   0x7e,			// 79 O alt: o
   0x1f,			// 80 P
   0x4f,			// 81 Q 
   0x11,			// 82 r
   0x6d,			// 83 S
   0x46,			// 84 T alt: t
   0x7a,			// 85 U V W
   0x7a,			// 86 V
   0x7a,			// 87 W
   0x5b,			// 88 X
   0x6b,			// 89 Y
   0x37,			// 90 Z

  0x3c,				// 91 [
   0x49,			// 92 '\\'
   0x66,			// 93 ]
   0x0e,			// 94 ^ ~
   0x20,			// 95 _
   0x02,			// 96 ` alt: '

  0x5f,				// 97 A R
   0x79,			// 98 b 
   0x31,			// 99 c
   0x73,			// 100 d 
   0x3d,			// 101 E
   0x1d,			// 102 F
   0x7c,			// 103 G
   0x59,			// 104 h
   0x42,			// 105 I 1
   0x62,			// 106 J alt 0x60 (worse)
   0x5b,			// 107 K alt h (worse?)
   0x38,			// 108 L
   0x51,			// 109 m n
   0x51,			// 110 n
   0x71,			// 111 o
   0x1f,			// 112 P
   0x4f,			// 113 q        
   0x11,			// 114 r
   0x6d,			// 115 S
   0x39,			// 116 t
   0x70,			// 117 u v w
   0x70,			// 118 v
   0x70,			// 119 w
   0x5b,			// 120 X
   0x6b,			// 121 Y
   0x37,			// 122 Z

  0x3c,				// 123 {
   0x18,			// 124 | (left) alt: 1 (worse)
   0x66,			// 125 }
   0x0e,			// 126 ~
   0x00				// 127 "" 127 empty
};

static inline void
_segon (int code)
{
  (*(char *) (0xef40 + (code >> 4))) |= (1<<(code & 0x0f));
}

static inline void
_segoff (int code)
{
  (*(char *) (0xef40 + (code >> 4))) &= ~(1<<(code & 0x0f));
}

void
LCDPrints (char *str)
{
  int i=0, j,seg;

  LCDClear();
  while (str[i] != 0 && i<6)
    {
      seg = ascii_display_codes[(int)str[i]];
      for (j = 0; j < 8; j++)
	{
	  if (seg & (1 << j))
	    _segon (segcode[i][j]);
	  else
	    _segoff (segcode[i][j]);
	}
      i++;
    }
  LCDRefresh();
}
